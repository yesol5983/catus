# Catus 프론트엔드 코드 정적 분석 보고서

**분석 목표**: 백엔드 API가 정상적으로 동작한다고 가정하고, 프론트엔드 React 코드 내에서 발생할 수 있는 잠재적인 문제점과 개선사항을 사용자 시나리오 기반으로 도출합니다.

---

## 종합 요약

Catus 프론트엔드 코드는 React Query를 사용한 데이터 관리, 체계적인 API 호출 등 좋은 구조를 갖추고 있습니다. 하지만 일부 주요 기능이 미구현 상태이며, 데이터 동기화, 에러 처리, 상태 관리 등에서 사용성을 저해할 수 있는 몇 가지 잠재적 문제점들이 발견되었습니다. 특히 **데이터 관리 방식(React Query vs. 일반 Hook)의 혼용**과 **전역 에러 처리 부재**가 가장 시급한 개선점으로 보입니다.

---

## 시나리오 1: 처음 방문한 사용자

> 처음 가입하여 온보딩과 첫 채팅을 경험하는 과정에서 발생할 수 있는 문제입니다.

### 1-1. 온보딩 및 튜토리얼 기능 미구현
- **현상**: `OnboardingPage.tsx`와 `Tutorial.tsx` 컴포넌트가 실제 기능 없이 "기능 구현 대기 중"이라는 플레이스홀더 UI만 보여주고 있습니다.
- **위치**: `src/pages/OnboardingPage.tsx`, `src/pages/Tutorial.tsx`
- **영향**: 신규 사용자가 앱의 핵심 가치를 경험하기 위한 필수 과정(온보딩, 튜토리얼)을 진행할 수 없습니다.
- **개선 제안**: 실제 질문-답변 형태의 온보딩 UI와 앱 사용법을 안내하는 튜토리얼 UI를 구현해야 합니다.

### 1-2. 채팅 데이터 관리 로직 분리
- **현상**: 채팅 페이지(`ChatPage.tsx`) 컴포넌트가 직접 IndexedDB 로직(`getChatMessagesByDate`, `saveChatMessage`)을 호출하고 있습니다. 채팅 관련 로직이 `useChat.ts` 훅과 `ChatPage.tsx` 컴포넌트에 분산되어 있습니다.
- **위치**: `src/pages/ChatPage.tsx`
- **영향**: 코드의 응집도가 떨어져 유지보수가 어렵습니다. 향후 다른 컴포넌트에서 채팅 기록을 재사용해야 할 경우, IndexedDB 로직을 중복으로 구현해야 할 수 있습니다.
- **개선 제안**: `ChatPage.tsx`에 있는 모든 IndexedDB 관련 로직을 `useChat.ts` 훅 내부로 옮겨, 훅이 데이터 영속성을 포함한 모든 채팅 관련 책임을 갖도록 리팩토링하는 것을 권장합니다.

### 1-3. 다이어리 생성 후 데이터 동기화 부재
- **현상**: 채팅 종료 후 일기를 생성하는 `handleSelectEmotion` 함수가 `chatApi.endConversation`을 직접 호출하며, 성공 시 React Query 캐시를 업데이트하는 로직이 없습니다.
- **위치**: `src/pages/ChatPage.tsx`
- **영향**: 사용자가 일기 생성 후 캘린더 페이지로 이동했을 때, 방금 생성한 일기가 즉시 보이지 않을 수 있습니다 (캐시된 이전 데이터를 보여주기 때문).
- **개선 제안**: `useApi.ts`에 정의된 `useCreateDiary`와 같은 `mutation` 훅을 사용하도록 변경하고, `onSuccess` 콜백에서 `queryClient.invalidateQueries`를 호출하여 캘린더(일기 목록) 관련 데이터가 새로고침되도록 해야 합니다.

---

## 시나리오 2: 성격이 급한 사용자

> 로딩이나 에러 상황에서 사용자가 겪을 수 있는 부정적인 경험에 대한 문제입니다.

### 2-1. 전역 에러 처리 부재
- **현상**: `ErrorBoundary.tsx`라는 훌륭한 에러 처리 컴포넌트가 존재하지만, 애플리케이션의 최상단인 `App.tsx`에서 이를 사용하고 있지 않습니다.
- **위치**: `src/App.tsx`
- **영향**: 렌더링 과정에서 예상치 못한 에러가 발생할 경우, 사용자에게는 에러 안내 화면 대신 아무것도 보이지 않는 '흰 화면'이 노출되어 앱 사용이 완전히 불가능해집니다.
- **개선 제안**: `App.tsx`에서 `<Router>` 컴포넌트 전체를 `<ErrorBoundary>`로 감싸서, 어떤 페이지에서 에러가 발생하더라도 앱 전체가 중단되는 것을 방지해야 합니다.

### 2-2. 일관성 없는 데이터 페칭 방식
- **현상**: `src/hooks/useDiary.ts`는 React Query를 사용하지 않고 `useState`와 `useEffect`로 직접 로딩/에러 상태를 관리하는 레거시(legacy) 방식으로 구현되어 있습니다. 반면 `src/hooks/useApi.ts`는 React Query 기반의 최신 훅들을 제공합니다. 현재 `CalendarPage.tsx`는 이 레거시 훅을 사용하고 있습니다.
- **위치**: `src/hooks/useDiary.ts`, `src/pages/CalendarPage.tsx`
- **영향**: 앱 전체적으로 데이터 캐싱, 자동 새로고침 등의 동작이 일관성 없게 됩니다. 이는 불필요한 API 호출을 유발하고, 데이터 동기화 문제를 일으킬 수 있습니다.
- **개선 제안**: `src/hooks/useDiary.ts` 파일을 완전히 제거하고, `CalendarPage.tsx`를 포함한 모든 컴포넌트가 `src/hooks/useApi.ts`에 정의된 React Query 훅을 사용하도록 통일해야 합니다.

---

## 시나리오 3: 꼼꼼한 파워 유저

> 앱을 구석구석 사용하며 복잡한 상태나 데이터가 없는 엣지 케이스에서 발생할 수 있는 문제입니다.

### 3-1. 미구현된 상세 페이지
- **현상**: `DiaryDetailPage.tsx`가 실제 일기 데이터를 불러와 보여주지 않고, 플레이스홀더 UI만 표시하고 있습니다.
- **위치**: `src/pages/DiaryDetailPage.tsx`
- **영향**: 사용자가 캘린더에서 특정 일기를 클릭해도 상세 내용을 확인할 수 없습니다.
- **개선 제안**: `useParams`로 `date`를 받아와, `useApi.ts`의 `useDiaryByDate` 훅을 사용하여 해당 날짜의 일기 데이터를 불러와 화면에 렌더링하는 기능을 구현해야 합니다.

### 3-2. IndexedDB 에러 처리 미흡
- **현상**: `indexedDB.ts`의 각 함수는 실패 시 Promise `reject`를 호출하지만, 이를 사용하는 `ChatPage.tsx`에서는 `catch` 블록에서 대부분 `console.error`로만 처리하고 있습니다.
- **위치**: `src/pages/ChatPage.tsx`
- **영향**: 사용자의 브라우저 설정 등으로 IndexedDB 쓰기/읽기에 실패했을 때, 사용자는 원인을 알 수 없으며 데이터가 유실될 수 있습니다.
- **개선 제안**: IndexedDB 관련 에러 발생 시, "채팅 기록을 불러오거나 저장하는 데 실패했습니다. 브라우저 설정을 확인해주세요."와 같은 사용자 친화적인 안내 메시지를 UI에 표시하는 로직을 추가해야 합니다.

---

## 시나리오 4: 개인정보에 민감한 사용자

> 로그아웃, 회원 탈퇴 등 데이터 처리의 안전성과 관련된 문제입니다.

### 4-1. 오프라인 시 로그아웃 처리
- **현상**: `AuthContext.tsx`의 `logout` 함수는 백엔드에 로그아웃 API를 호출한 후 로컬 데이터를 삭제합니다. 만약 사용자가 오프라인 상태에서 로그아웃을 시도하면 API 호출은 실패하고, `catch` 블록에서 에러를 콘솔에만 기록합니다.
- **위치**: `src/contexts/AuthContext.tsx`
- **영향**: 기능적으로 로컬 데이터는 삭제되어 로그아웃이 되지만, 개발자 콘솔에 불필요한 에러가 표시될 수 있습니다. 이는 사소한 문제이지만 코드 완성도를 떨어뜨립니다.
- **개선 제안**: `logout` 함수 내 API 호출 실패는 네트워크가 끊긴 자연스러운 상황일 수 있으므로, `catch` 블록에서 굳이 에러를 콘솔에 출력하지 않거나, "서버와 연결이 끊겨 로컬에서만 로그아웃됩니다."와 같이 더 명확하게 처리하는 것을 고려할 수 있습니다.
- **결론**: 현재 로직이 사용자 경험에 큰 문제를 일으키지는 않으므로 우선순위는 낮습니다.

**전반적으로, 사용자 데이터 삭제(로그아웃, 회원탈퇴) 관련 로직은 안전하게 잘 구현되어 있는 것으로 보입니다.**
